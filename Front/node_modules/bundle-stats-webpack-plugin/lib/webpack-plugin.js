"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BundleStatsWebpackPlugin = void 0;

require("core-js/modules/es.promise.js");

require("core-js/modules/es.array.iterator.js");

var _webpack = _interopRequireDefault(require("webpack"));

var _path = _interopRequireDefault(require("path"));

var _process = _interopRequireDefault(require("process"));

var _lodash = require("lodash");

var _utils = require("@bundle-stats/utils");

var _webpack2 = require("@bundle-stats/utils/lib/webpack");

var _cliUtils = require("@bundle-stats/cli-utils");

var _locales = _interopRequireDefault(require("../locales.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_OPTIONS = {
  compare: true,
  baseline: Boolean(_process.default.env.BUNDLE_STATS_BASELINE),
  html: true,
  json: false,
  outDir: '',
  silent: false,
  stats: {
    context: _process.default.cwd(),
    assets: true,
    entrypoints: true,
    chunks: true,
    modules: true,
    hash: true,
    builtAt: true
  }
};
const PLUGIN_NAME = 'BundleStats';
const isWebpack5 = parseInt(_webpack.default.version, 10) === 5;

const generateReports = async (compilation, options) => {
  var _compilation$options, _compilation$options$;

  const {
    compare,
    baseline,
    html,
    json,
    outDir
  } = options;
  const newAssets = {};
  const logger = compilation.getInfrastructureLogger ? compilation.getInfrastructureLogger(PLUGIN_NAME) : console;
  const source = compilation.getStats().toJson(options.stats);
  const outputPath = compilation === null || compilation === void 0 ? void 0 : (_compilation$options = compilation.options) === null || _compilation$options === void 0 ? void 0 : (_compilation$options$ = _compilation$options.output) === null || _compilation$options$ === void 0 ? void 0 : _compilation$options$.path;
  const invalid = (0, _webpack2.validate)(source);

  if (invalid) {
    logger.warn(`${invalid}\n${_locales.default.WEBPACK_CONFIGURATION_URL}`);
  }

  const data = (0, _webpack2.filter)(source); // Webpack builtAt is not available yet

  if (!data.builtAt) {
    data.builtAt = Date.now();
  }

  const baselineFilepath = (0, _cliUtils.getBaselineStatsFilepath)(outputPath);
  let baselineStats = null;

  try {
    if (compare) {
      baselineStats = await (0, _cliUtils.readBaseline)();
      baselineStats = (0, _webpack2.filter)(baselineStats);
      if (!options.silent) logger.info(`Read baseline from ${baselineFilepath}`);
    }
  } catch (err) {
    logger.warn(_cliUtils.TEXT.PLUGIN_BASELINE_MISSING_WARN);
  }

  const jobs = (0, _utils.createJobs)([{
    webpack: data
  }, ...(compare ? [{
    webpack: baselineStats
  }] : [])]);
  const report = (0, _utils.createReport)(jobs);
  const artifacts = (0, _cliUtils.createArtifacts)(jobs, report, {
    html,
    json
  });
  Object.values(artifacts).forEach(({
    filename,
    output
  }) => {
    const filepath = _path.default.join(outDir, filename); // eslint-disable-next-line no-param-reassign


    newAssets[filepath] = output;
  });

  if (baseline) {
    // eslint-disable-next-line no-param-reassign
    newAssets[baselineFilepath] = JSON.stringify(data);
    if (!options.silent) logger.info(`Write baseline data to ${baselineFilepath}`);
  }

  const info = (0, _cliUtils.getReportInfo)(report);

  if (info && !options.silent) {
    logger.info(info.text);
  }

  return newAssets;
};

class BundleStatsWebpackPlugin {
  constructor(options) {
    this.options = options;
  }

  apply(compiler) {
    var _compiler$options;

    const options = (0, _lodash.merge)({}, DEFAULT_OPTIONS, {
      stats: {
        context: (_compiler$options = compiler.options) === null || _compiler$options === void 0 ? void 0 : _compiler$options.context
      }
    }, this.options);

    if (isWebpack5) {
      compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation => {
        compilation.hooks.processAssets.tapPromise({
          name: PLUGIN_NAME,
          stage: _webpack.default.Compilation.PROCESS_ASSETS_STAGE_REPORT
        }, async () => {
          const newAssets = await generateReports(compilation, options);
          Object.entries(newAssets).forEach(([filename, source]) => {
            compilation.emitAsset(filename, new _webpack.default.sources.RawSource(source), {
              development: true
            });
          });
        });
      });
      return;
    }

    compiler.hooks.emit.tapAsync(PLUGIN_NAME, async (compilation, callback) => {
      const newAssets = await generateReports(compilation, options);
      Object.entries(newAssets).forEach(([filename, source]) => {
        // eslint-disable-next-line no-param-reassign
        compilation.assets[filename] = {
          size: () => 0,
          source: () => source
        };
      });
      callback();
    });
  }

}

exports.BundleStatsWebpackPlugin = BundleStatsWebpackPlugin;